// Grammar for the
//
//    mm
//    ##    mmm    mmm
//   #  #  "   #  "   #
//   #mm#  m"""#  m"""#
//  #    # "mm"#  "mm"#
//
// language.

%import common.WS
%ignore WS

COMMENT: "//" /[^\n]*/ "\n"
%ignore COMMENT

SHEBANG: "#!" /[^\n]*/ "\n"
%ignore SHEBANG

identifier: /(?!(as|args|bool|begin|end|else|false|fn|from|int|map|return|str|true|vec|while))([a-z_]+)/ // TODO add all keywords here
integer: /[0-9]+/

%import common.ESCAPED_STRING
string: ESCAPED_STRING

// ignored keywords
_AS:         /as(?=(\W|\s))/
_ARGS:       /args(?=(\W|\s))/
_BEGIN:      /begin(?=(\W|\s))/
_BUILTIN_FN: /builtin_fn(?=(\W|\s))/
_END:        /end(?=(\W|\s|$))/
_ELSE:       /else(?=(\W|\s))/
_FN:         /fn(?=(\W|\s))/
_FROM:       /from(?=(\W|\s))/
_IMPORT:     /import(?=(\W|\s))/
_IF:         /if(?=(\W|\s))/
_RETURN:     /return(?=(\W|\s))/
_STRUCT:     /struct(?=(\W|\s))/
_WHILE:      /while(?=(\W|\s))/

// keywords for builtin types
BOOL:       /bool(?=(\W|\s))/
INT:        /int(?=(\W|\s))/
MAP:        /map(?=(\W|\s))/
STR:        /str(?=(\W|\s))/
VEC:        /vec(?=(\W|\s))/

// keywords for builtin constants
FALSE:      /false(?=(\W|\s))/
TRUE:       /true(?=(\W|\s))/

builtins_file_root: builtin_function_definition+

builtin_function_definition: _BUILTIN_FN string builtin_function_arguments? builtin_function_return_types?

builtin_function_arguments: _ARGS return_types

builtin_function_return_types: _RETURN return_types

regular_file_root: (function_definition | import_statement | struct_definition)+

// TODO consider supporting empty struct using nop syntax
struct_definition: _STRUCT identifier _BEGIN argument_list _END

import_statement: _FROM string _IMPORT import_items

import_items: import_item ("," import_item)* ","?

import_item: identifier (_AS identifier)?

struct_function_definition: identifier ":" identifier

function_definition: _FN function_name function_arguments? function_return_types? _BEGIN function_body _END

function_name: struct_function_definition | identifier

function_arguments: _ARGS argument_list

function_return_types: _RETURN return_types


!type_literal: (BOOL | INT | MAP | STR | VEC | identifier) type_params?

type_params: "[" type ("," type)* ","? "]"

type_placeholder: "*" identifier

argument: identifier _AS type

argument_list: argument ("," argument)* ","?

type: type_literal | type_placeholder

return_types: type ("," type)* ","?

function_body: function_body_item+

member_function: type_literal ":" identifier

function_body_item:   member_function
                    | branch
                    | loop
                    | operator
                    | identifier
                    | type_literal
                    | struct_field_query
                    | struct_field_update
                    | literal

branch: branch_condition branch_if_body branch_else_body? _END

branch_condition: _IF function_body
branch_if_body: _BEGIN function_body
branch_else_body: _ELSE function_body


loop: loop_condition loop_body _END

loop_condition: _WHILE function_body
loop_body: _BEGIN function_body


struct_field_query: string "?"

struct_field_update: string function_body "!"

literal: boolean | integer | string

!boolean: TRUE | FALSE

// TODO find out which ones of these should be keywords (add to identifier blacklist)
// TODO find out which ones are regular functions (remove here)
!operator:    "and"
            | "assert"
            | "drop"
            | "dup"
            | "nop"
            | "not"
            | "or"
            | "over"
            | "rot"
            | "strlen" // TODO unreachable, parses as str len
            | "substr"
            | "swap"
            | /-(?=\s)/
            | /!=(?=\s)/
            | /\.(?=\s)/
            | /\*(?=\s)/
            | /\/(?=\s)/
            | /%(?=\s)/
            | /\+(?=\s)/
            | /<=(?=\s)/
            | /=(?=\s)/
            | />=(?=\s)/
            | /<(?=\s)/
            | />(?=\s)/
