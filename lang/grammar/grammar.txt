// Grammar for the
//
//    mm
//    ##    mmm    mmm
//   #  #  "   #  "   #
//   #mm#  m"""#  m"""#
//  #    # "mm"#  "mm"#
//
// language.

// --- control flow keyword tokens ---

@ token ARGS         = regex("args(?=\\s|$)")         .
@ token AS           = regex("as(?=\\s|$)")           .
@ token BEGIN        = regex("begin(?=\\s|$)")        .
@ token BUILTIN_FN   = regex("builtin_fn(?=\\s|$)")   .
@ token BUILTIN_TYPE = regex("builtin_type(?=\\s|$)") .
@ token ELSE         = regex("else(?=\\s|$)")         .
@ token END          = regex("end(?=\\s|$)")          .
@ token FN           = regex("fn(?=\\s|$)")           .
@ token FROM         = regex("from(?=\\s|$)")         .
@ token IF           = regex("if(?=\\s|$)")           .
@ token IMPORT       = regex("import(?=\\s|$)")       .
@ token RETURN       = regex("return(?=\\s|$)")       .
@ token WHILE        = regex("while(?=\\s|$)")        .

// --- operator tokens ---

@ token AND            = regex("and(?=\\s|$)")    .
@ token ASSERT         = regex("assert(?=\\s|$)") .
@ token ASTERISK       = "*"                      .
@ token BACKSLASH_N    = regex("\\\\n(?=\\s|$)")  .
@ token COMMA          = regex(",(?=\\s|$)")      .
@ token DROP           = regex("drop(?=\\s|$)")   .
@ token DUP            = regex("dup(?=\\s|$)")    .
@ token EQUALS         = regex("=(?=\\s|$)")      .
@ token GREATER_EQUALS = regex(">=(?=\\s|$)")     .
@ token GREATER_THAN   = regex(">(?=\\s|$)")      .
@ token LESS_EQUALS    = regex("<=(?=\\s|$)")     .
@ token LESS_THAN      = regex("<(?=\\s|$)")      .
@ token MINUS          = regex("-(?=\\s|$)")      .
@ token NOP            = regex("nop(?=\\s|$)")    .
@ token NOT            = regex("not(?=\\s|$)")    .
@ token NOT_EQUALS     = regex("!=(?=\\s|$)")     .
@ token OR             = regex("or(?=\\s|$)")     .
@ token OVER           = regex("over(?=\\s|$)")   .
@ token PERCENT        = regex("%(?=\\s|$)")      .
@ token PERIOD         = regex("\\.(?=\\s|$)")    .
@ token PLUS           = regex("\\+(?=\\s|$)")    .
@ token ROT            = regex("rot(?=\\s|$)")    .
@ token SLASH          = regex("/(?=\\s|$)")      .
@ token STRLEN         = regex("strlen(?=\\s|$)") .
@ token SUBSTR         = regex("substr(?=\\s|$)") .
@ token SWAP           = regex("swap(?=\\s|$)")   .

// --- literal tokens ---

@ token TRUE       = regex("true(?=\\s|$)")  .
@ token FALSE      = regex("false(?=\\s|$)") .

// --- builtin types ---

@ token INT  =  regex("int(?=\\s|$)")  .
@ token STR  =  regex("str(?=\\s|$)")  .
@ token BOOL =  regex("bool(?=\\s|$)") .

// --- more generic literal tokens ---

@ token IDENTIFIER = regex("[a-z_]+")                         .
@ token INTEGER    = regex("[0-9]+")                          .
@ token STRING     = regex("\"([^\\\\]|\\\\(\"|n|\\\\))*?\"") .

// --- pruned tokens ---

@ token @ prune WHITESPACE = regex("([ \n]|$)+") .
@ token @ prune COMMENT    = regex("//[^\n]*")   .
@ token @ prune SHEBANG    = regex("#![^\n]*")   .

// ---

ROOT = REGULAR_FILE_ROOT | BUILTINS_FILE_ROOT .

BUILTINS_FILE_ROOT = BUILTIN_FUNCTION_DEFINITION | BUILTIN_TYPE_DEFINITION .

BUILTIN_FUNCTION_DEFINITION = BUILTIN_FN STRING (ARGS RETURN_TYPES)? (RETURN RETURN_TYPES)? .

BUILTIN_TYPE_DEFINITION = BUILTIN_TYPE STRING .

REGULAR_FILE_ROOT = (FUNCTION_DEFINITION | IMPORT_STATEMENT)* .

IMPORT_STATEMENT = FROM STRING IMPORT IMPORT_ITEMS .

IMPORT_ITEMS = IMPORT_ITEM (COMMA IMPORT_ITEM)* (COMMA)? .

IMPORT_ITEM = IDENTIFIER (AS IDENTIFIER)? .

FUNCTION_DEFINITION = FN IDENTIFIER (ARGS ARGUMENT_LIST)? (RETURN RETURN_TYPES)? BEGIN FUNCTION_BODY END .

TYPE_LITERAL = INT | STR | BOOL .

@ prune
TYPE_PLACEHOLDER = ASTERISK IDENTIFIER .

@ prune
TYPED_ARGUMENT = IDENTIFIER AS (IDENTIFIER | TYPE_LITERAL) .

ARGUMENT = TYPE_PLACEHOLDER | TYPED_ARGUMENT .

ARGUMENT_LIST = ARGUMENT (COMMA ARGUMENT)* (COMMA)? .

RETURN_TYPE = TYPE_LITERAL | IDENTIFIER | TYPE_PLACEHOLDER .

RETURN_TYPES = RETURN_TYPE (COMMA RETURN_TYPE)* (COMMA)? .

FUNCTION_BODY = (FUNCTION_BODY_ITEM)+ .

@ prune
FUNCTION_BODY_ITEM = BRANCH | LOOP | OPERATOR | IDENTIFIER | LITERAL .

BRANCH = IF FUNCTION_BODY BEGIN FUNCTION_BODY (ELSE FUNCTION_BODY)? END .

LOOP = WHILE FUNCTION_BODY BEGIN FUNCTION_BODY END .

@ prune
LITERAL = BOOLEAN | INTEGER | STRING .

BOOLEAN = TRUE | FALSE .

OPERATOR = (
      AND
    | ASSERT
    | ASTERISK
    | BACKSLASH_N
    | DROP
    | DUP
    | EQUALS
    | GREATER_EQUALS
    | GREATER_THAN
    | LESS_EQUALS
    | LESS_THAN
    | MINUS
    | NOP
    | NOT
    | NOT_EQUALS
    | OR
    | OVER
    | PERCENT
    | PERIOD
    | PLUS
    | ROT
    | SLASH
    | STRLEN
    | SUBSTR
    | SWAP
) .
