// Grammar for the
//
//    mm
//    ##    mmm    mmm
//   #  #  "   #  "   #
//   #mm#  m"""#  m"""#
//  #    # "mm"#  "mm"#
//
// language.

// --- control flow keyword tokens ---

@ token ARGS   = regex("args(?=\\W|$)")   .
@ token AS     = regex("as(?=\\W|$)")     .
@ token BEGIN  = regex("begin(?=\\W|$)")  .
@ token BUILTIN_FN   = regex("builtin_fn(?=\\W|$)")   .
@ token BUILTIN_TYPE = regex("builtin_type(?=\\W|$)") .
@ token ELSE   = regex("else(?=\\W|$)")   .
@ token END    = regex("end(?=\\W|$)")    .
@ token FN     = regex("fn(?=\\W|$)")     .
@ token FROM   = regex("from(?=\\W|$)")   .
@ token IF     = regex("if(?=\\W|$)")     .
@ token IMPORT = regex("import(?=\\W|$)") .
@ token RETURN = regex("return(?=\\W|$)") .
@ token WHILE  = regex("while(?=\\W|$)")  .

// --- operator tokens ---

@ token AND            = regex("and(?=\\W|$)")    .
@ token ASSERT         = regex("assert(?=\\W|$)") .
@ token ASTERISK       = "*"                      .
@ token BACKSLASH_N    = regex("\\\\n(?=\\W|$)")  .
@ token COMMA          = regex(",(?=\\s|$)")      .
@ token DROP           = regex("drop(?=\\W|$)")   .
@ token DUP            = regex("dup(?=\\W|$)")    .
@ token EQUALS         = regex("=(?=\\s|$)")      .
@ token GREATER_EQUALS = regex(">=(?=\\s|$)")     .
@ token GREATER_THAN   = regex(">(?=\\s|$)")      .
@ token LESS_EQUALS    = regex("<=(?=\\s|$)")     .
@ token LESS_THAN      = regex("<(?=\\s|$)")      .
@ token MINUS          = regex("-(?=\\s|$)")      .
@ token NOP            = regex("nop(?=\\W|$)")    .
@ token NOT            = regex("not(?=\\W|$)")    .
@ token NOT_EQUALS     = regex("!=(?=\\s|$)")     .
@ token OR             = regex("or(?=\\W|$)")     .
@ token OVER           = regex("over(?=\\W|$)")   .
@ token PERCENT        = regex("%(?=\\s|$)")      .
@ token PERIOD         = regex("\\.(?=\\s|$)")    .
@ token PLUS           = regex("\\+(?=\\s|$)")    .
@ token ROT            = regex("rot(?=\\W|$)")    .
@ token SLASH          = regex("/(?=\\s|$)")      .
@ token STRLEN         = regex("strlen(?=\\W|$)") .
@ token SUBSTR         = regex("substr(?=\\W|$)") .
@ token SWAP           = regex("swap(?=\\W|$)")   .

// --- literal tokens ---

@ token FALSE      = regex("false(?=\\W|$)") .
@ token TRUE       = regex("true(?=\\W|$)")  .

// --- builtin types ---

@ token BOOL = regex("bool(?=\\W|$)") .
@ token INT  = regex("int(?=\\W|$)")  .
@ token MAP  = regex("map(?=\\W|$)")  .
@ token STR  = regex("str(?=\\W|$)")  .
@ token VEC  = regex("vec(?=\\W|$)")  .

// --- type param blocks ---

@ token TYPE_PARAMS_START = "[" .
@ token TYPE_PARAMS_END   = "]" .

// --- more generic literal tokens ---

@ token IDENTIFIER = regex("[a-z_]+")                         .
@ token INTEGER    = regex("[0-9]+")                          .
@ token STRING     = regex("\"([^\\\\]|\\\\(\"|n|\\\\))*?\"") .

// --- pruned tokens ---

@ token @ prune COMMENT    = regex("//[^\n]*")   .
@ token @ prune WHITESPACE = regex("([ \n]|$)+") .
@ token @ prune SHEBANG    = regex("#![^\n]*")   .

// ---

ROOT = REGULAR_FILE_ROOT | BUILTINS_FILE_ROOT .

BUILTINS_FILE_ROOT = (BUILTIN_FUNCTION_DEFINITION | BUILTIN_TYPE_DEFINITION)+ .

BUILTIN_FUNCTION_DEFINITION = BUILTIN_FN STRING (ARGS RETURN_TYPES)? (RETURN RETURN_TYPES)? .

BUILTIN_TYPE_DEFINITION = BUILTIN_TYPE STRING .

REGULAR_FILE_ROOT = (FUNCTION_DEFINITION | IMPORT_STATEMENT)+ .

IMPORT_STATEMENT = FROM STRING IMPORT IMPORT_ITEMS .

IMPORT_ITEMS = IMPORT_ITEM (COMMA IMPORT_ITEM)* (COMMA)? .

IMPORT_ITEM = IDENTIFIER (AS IDENTIFIER)? .

FUNCTION_DEFINITION = FN IDENTIFIER (ARGS ARGUMENT_LIST)? (RETURN RETURN_TYPES)? BEGIN FUNCTION_BODY END .

TYPE_LITERAL = (
      BOOL
    | INT
    | MAP_TYPE_LITERAL
    | STR
    | VEC_TYPE_LITERAL
) .

MAP_TYPE_LITERAL = MAP TYPE_PARAMS_START TYPE_LITERAL COMMA TYPE_LITERAL TYPE_PARAMS_END .

VEC_TYPE_LITERAL = VEC TYPE_PARAMS_START TYPE_LITERAL TYPE_PARAMS_END .

TYPE_PLACEHOLDER = ASTERISK IDENTIFIER .

@ prune
TYPED_ARGUMENT = IDENTIFIER AS TYPE_LITERAL .

ARGUMENT = TYPE_PLACEHOLDER | TYPED_ARGUMENT .

ARGUMENT_LIST = ARGUMENT (COMMA ARGUMENT)* (COMMA)? .

RETURN_TYPE = TYPE_LITERAL | TYPE_PLACEHOLDER .

RETURN_TYPES = RETURN_TYPE (COMMA RETURN_TYPE)* (COMMA)? .

FUNCTION_BODY = (FUNCTION_BODY_ITEM)+ .

@ prune
FUNCTION_BODY_ITEM = BRANCH | LOOP | OPERATOR | IDENTIFIER | LITERAL | TYPE_LITERAL .

BRANCH = IF FUNCTION_BODY BEGIN FUNCTION_BODY (ELSE FUNCTION_BODY)? END .

LOOP = WHILE FUNCTION_BODY BEGIN FUNCTION_BODY END .

@ prune
LITERAL = BOOLEAN | INTEGER | STRING .

BOOLEAN = TRUE | FALSE .

OPERATOR = (
      AND
    | ASSERT
    | ASTERISK
    | BACKSLASH_N
    | DROP
    | DUP
    | EQUALS
    | GREATER_EQUALS
    | GREATER_THAN
    | LESS_EQUALS
    | LESS_THAN
    | MINUS
    | NOP
    | NOT
    | NOT_EQUALS
    | OR
    | OVER
    | PERCENT
    | PERIOD
    | PLUS
    | ROT
    | SLASH
    | STRLEN
    | SUBSTR
    | SWAP
) .
